<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <title>Guigen - overview</title>
   </head>

   <body>
      <h2>
         Guigen - overview
      </h2>
      <h3>Introduzione</h3>

	<p>
	<b>GUIGEN</b> &egrave; un generatore <b>model-driven</b> di front-end applicativi.
	Permette la generazione di applicazioni <end-user> a partire da un modello dichiarativo dell'applicazione e con l'aggiunta manuale 
	di codice custom a completamento della logica di business (principalmente per la realizzazione dell'interazione con il backend, con
	servizi esterni o con risorse quali DBMS).
	</p>
	<p>
 	Il modello che descrive l'applicazione è basato su un metamodello descritto in dettaglio in <a href="mm_reference.html">[Metamodel reference]</a> e ricopre vari aspetti di una
 	applicazione:
 	
 	  <ul>
 	  <li>caratteristiche strutturali
 	    <ul>
 	    <li>struttura delle schermate</li>
 		<li>struttura dei menu delle funzionalità</li>
 		</ul>
 	  </li>	
 	  <li>caratteristiche dinamiche
        <ul>
        <li>flusso tra le schermate
          <ul>
          <li>eventi associati ai vari componenti di controllo (menu, pulsanti, etc.)</li>
          <li>azioni (comandi) scatenate a fronte di un evento su un componente di controllo</li>
          <li>modifica stato dei widget (disabilitazione/visibilità, ...)</li>
 		  </ul>
 		</li>
 		</ul>
 	  </li>	
 	  <li>caratteristiche di binding dati
 	    <ul>
 	    <li>definizione di strutture dati (model)</li>
 		<li>binding bidirezionale tra widget e dati del model</li>
 		</ul>
 	  </li>
 	</ul>
 	</p>
 	<p>
	Il metamodello secondo il quale occorre modellare l'applicazione &egrave; indipendente da una particolare modalit&agrave;/tecnologia
 	di realizzazione dell'applicazione, utilizzando concetti generali (es. widget, event-handler, panels) e non <b>technology-specific</b>
 	(es. submit, JTree, ...): di conseguenza il generatore GUIGEN può in linea teorica generare un'applicazione modellata secondo tale
 	metamodello utilizzando differenti tecnologie di implementazione. 
 	</p>
 	<p>
 	Attualmente il target di generazione è rappresentato da una web-application J2EE compliant con l'attuale framework applicativo basato
 	su tecnologie Servlet/JSP e framework struts2. Per approfondimenti circa il mapping tram modello GUIGEN e piattaforma specifica 
 	(ovvero per comprendere meglio le regole di generazione del codice a frointe del metamodello, &egrave;
 	possibile consultare la sezione <a href="rationale.html">design rationale</a>.   	 
	</p>
	
	<h3>Funzionalit&agrave;</h3>
  
	Di seguito sono elencate le principali funzionalit&agrave; messe a disposizione dal generatore GUIGEN.
	
    <h4>Definizione della struttura della User Interface dell'applicativo</h4>

	La U.I dell'applicazione &egrave; organizzata in alcune aree prinicpali:
	
	  <ol>
	  <li>un <b>header</b> e un <b>footer</b> che contengono informazioni statiche non gestite da applicativo (che in genere sono determinate dalla 
	      collocazione di un applicativo in un particolare contesto (es. sito web) e che non varia da applicazione ad applicazione</li>
		
	  <li>una area applicativa <b>ApplicationArea</b> che dipende dalla particolare applicazione. A sua volta questa area applicativa è
		  strutturata in:
	    <ul>  
		<li>una struttura a menu (<b>MenuBar</b>)</li>			
		<li>un'insieme di schermate applicative (<b>ContentPanel</b>) che si avvicendano a fronte del flusso funzionale dell'applicativo e sono 
		visualizzate all'interno dell'area invariante (header, footer). Il menu è gestito come widget in modo da poter essere collocato 
		in tutte le schermate.</li>
	    </ul> 
	  </li>
	  </ol>
	  
	Ciascuna schermata contiene <b>Widget</b> di vario genere strutturati in pannelli (<b>Panel</b>) che possono essere dei seguenti tipi:
	  
	  <ul>
	  <li><b>FormPanel</b>: pannello destinato a contenere <b>widget</b> o <b>sottopannelli</b></li>
		
	  <li><b>CommandPanel</b>: tipo specializzato di <b>FormPanel</b> che può contenere solo <b>widget</b> di tipo <b>Command</b> (pulsanti)</li>
		 
	  <li><b>MenuPanel</b>: tipo specializzato di <b>FormPanel</b> che può contenere solo <b>widget</b> di tipo menu o affini (attualmente
		   solo <b>MenuView</b> o <b>TreeView</b>).</li>
		
	  <li><b>TabSetPanel</b>: il classico pannello a tab (il contenuto di ciascun tab è a sua volta un <b>pannello</b>)</li>
		
	  <li><b>DialogPanel</b>: pannello utilizzato per la visualizzazione di popup</li>
	  </ul>
	  
	Ciascun singolo pannello prevede uno schema di layout (selezionabile in un insieme di possibilità) secondo cui i sottopannelli 
	e i widget vengono disposti:
	
	  <ul>  
	  <li>Disposizione a cascata verticale su un'unica colonna (<b>VerticalFlowPanelLayout</b>); 
	    <ul>	
	  	<li>applicabile a sottopannelli e widget</li>;
	  		
	  	<li>l'ordine di visualizzazione è dall'alto in basso a seconda dell'ordine in cui i componenti appaiono nel modello (non sono 
	  		necessarie delle <b>layout specification</b> aggiuntive</li>);
	  	</ul>
	  </li>
	  <li>	
	  	Disposizione in sequenza orizzontale <b>left to right</b> su un'unica riga (<b>HorizontalFlowPanelLayout</b>)
	  	<ul>
	  	<li>applicabile a sottopannelli e widget</li>;
	  		
	  	<li>l'ordine di visualizzazione è dasinistra a destra a seconda dell'ordine in cui i componenti appaiono nel modello (non sono 
	  		  necessarie delle <b>layout specification</b> aggiuntive</li>;
	  	</ul>
	  </li>
	  <li>	
	  	Disposizione a 5 quadranti (<b>UpDownLeftRightCenterPanelLayout</b>)
		<ul>
		<li>applicabile al pannello principale o a command panel (in questo caso sono disponibili solo le posizioni Left e Right e 
			  servono per implementare plusantiere di navigazione del tipo indietro-prosegui)</li>;
			
		<li>pu&ograve; contenere al massimo 5 sottopannelli, 1 al massimo per sezione, ed è necessario specificare 
			  esplicitamente per ciascun elemento il quadrante di destinazione (mediante una <b>UDLRCWidgetLayoutSpec</b>)</li>;
		</ul>   
	  </li>
	  <li>
		Disposizione a griglia <b>n</b>X<b>m</b> (<b>GridPanelLayout</b>)
		<ul>
		<li>applicabile solo a sottopannelli</li>
			
		<li>pu&ograve; contenere al max. <b>n</b> X <b>m</b> widget o sottopannelli (uno per cella della griglia - ogni widget 
		comprende tutti gli elementi grafici utili a realizzarlo, quali label, widget vero e proprio etc..)</li>
			  
		<li>per ciascun widget &egrave; possibile specificare con precisione la posizione nella griglia e, opzionalmente, il numero di colonne
		per cui la porzione <b>non-label</b> del widget si deve estendere (1 colonna = 1 posto per un widget completo, indipendentemente
		dal numero di elementi grafici utilizzati nel codice generato.</li>
		</ul>    
	   </li>
	   </ul>
	   
	I widget disponibili condividono alcuni comportamenti comuni:
	<ul>	
	<li>possono essere disabilitati o abilitati a comando (abiltazione/disabilitazione/stato di default): se disabilitati non possono 
		accettare input o comandi dall'utente</li>
	<li>possono essere visibili/invisibili o abilitati/disabilitati a fronte di <b>Security constraints</b> che possono essere
	    o meno soddisfatti per l'utente correntemente collegato all'applicazione.			
	
	<li>possono essere resi invisibili o nuovamente visibili a comando (visibile/invisibile/stato di default)</li>
				
	<li>possono essere posizionati con precisione nel pannello contenitore utilizzando una parametrizzazione specifica
		  del tipo di layout del contenitore (vedi sopra)</li>
		  
	<li>possono essere corredati da un <b>EventHandler</b> in grado di gestire eventi di interazione umana (per l'elenco delle tipologie
	di eventi supportate da ciascun widget e per dettagli sulla gestione degli eventi si vedano le sezioni apposite).</li>
	
    <h5> Widget disponibili</h5>

	<ul>
	<li><b>CommandWidget</b>: widget che hanno lo scopo di gestire <i>comandi utente</i>. I <b>CommandWidget</b> condividono la possibilit&agrave; 
	    di catturare eventi di user interaction (vedere sotto). Sono disponibili i seguenti widget: 
	  <ul>
			<li>Pulsanti (<b>ConfirmButton</b>) che permettono l'esecuzione di una serie di azioni/comandi</li>
			
			<li>Pulsanti che permettono la pulizia della schermata (<b>ResetButton</b>)</li>
			
			<li>Menu (la struttura &egrave; definita centralmente nell'applicativo; questo widget &egrave; solo un segnaposto necessario per
			collocare il menu all'interno della schermata)</li>
	  </ul>
	</li>			

	<li><b>DataWidget</b>: widget destinati all'input/output di informazioni.
	  <ul>
		<li>condividono alcuni comportamenti comuni aggiuntivi rispetto ai widget generici:
		  <ul>		  
			<li>sono dotati di tipo</li>
				
			<li>prevedono la possibilit&agrave; di effettuare una serie di validazioni sull'input immesso</li>
				
			<li>possono essere collegati al <i>model</i> mediante appositi binding (<b>AppDataBinding</b>)</li>
				
			<li>possono essere valorizzati in base allo stato dell'applicazione</li> 
				
			<li>possono passare l'informazione immessa dall'utente ai moduli di logica applicativa (esclusi <b>Image</b>, <b>StaticText</b>)
		  </ul>
		</li>		
		<li>sono disponibili i seguenti widget:
		  <ul>
		  <li>Campi di immissione testo monolinea (<b>TextField</b>) o multilinea (<b>TextArea</b>)</li>
			
		  <li>Drop-down list (<b>ComboBox</b>)</li>
			
		  <li>Pulsante on-off (<b>Check Box</b>)</li>
			
		  <li>Pulsanti a scelta esclusiva (<b>RadioButton</b>)</li>
			
		  <li>Tabella di visualizzazione (read-only) con possibilità di ordinamento, paginazione, export dei dati in vari formati, selezione di
		  	  una o pi&ugrave; righe per l'esecuzione di un'azione su di esse</li>
		
		  <li>Albero espandibile (<b>TreeView</b>)
				
		  <!--<li>Variante dell'albero espandibile <b>MenuTree</b> che serve per inserire la struttura di menu in una posizione particolare, come fosse
			  un normale widget</li>-->
			
		  <li>Immagine (<b>Image</b>)</li>
			
		  <li>Testo puro (<b>PlainText</b>, widget per sola visualizzazione)</li>
		  </ul>
	    </li>
	    </ul>
	  </li>
	</ul>				  
	</p>
<h4>Definizione del <b>model</b> gestito nell'applicativo</h4>
	
	<p>
	Lo strato di model nell'applicativo &egrave costituito da:
	
	<ul>
	<li>definizioni di <b>tipi</b> complessi relativi agli oggetti che dovranno essere maneggiati dalla logica applicativa (strutture dati)</li>
	
	<li>definizioni di <b>ApplicationData</b>, che rappresentano le porzioni di informazione (strettamente tipizzate) che vengono maneggiate
	  all'interno della logica applicativa e dallo strato di view:
	  <ul>
	  	<li>hanno un nome che li identifica a livello di applicazione e con il quale possono essere referenziati all'interno delle GUI o nella
	  	  logica applicativa</li>
	  	  
	  	<li>sono tipizzati (tipi semplici o complessi o collezioni di tipi semplici o complessi)</li>
	  	
	  	<li>possono "vivere" per il solo tempo di una singola <b>interazione utente</b> (scope = USER_ACTION) oppure per più interazioni successive 
	  	  scope USER_SESSION)</li>
	  </ul>
	</li>
	</ul>
	</p>
	<p>
	la logica di business sar&agrave; nettamente separata dalla logica di U.I e dovr&agrave; essere codificata manualmente:
	
	<ul>
	<li>avendo a disposizione gli <b>ApplicationData</b> necessari, il cui valore &egrave; pre-compilato (se necessario) a fronte dell'input utente sulle
		GUI a cui tali dati sono collegati o a fronte del valore contenuto in sessione se l'<b>ApplicationData</b> &egrave; a scope USER_SESSION;</li>
		
	<li>restituendo al gestore del contesto applicativo gli <b>ApplicationData</b> creati/modificati dalla logica, in modo che possano
		  essere maneggiati dallo strato di presentation</li>
		  
	<li>implementando metodi con una interfaccia ben definita</li>
		
	<li>il collegamento tra U.I, controller e model/logica &egrave; modellato come spiegato nel paragrafo successivo</li>  
</p>
<h4>Definizione del comportamento dinamico dell'applicativo</h4>
<p>
	Il comportamento dinamico dell'applicativo si concretizza nella possibilit&agrave; di associare una serie di comandi agli
	eventi di user interaction che avvengono sull'applicativo.
	In particolare sono disponibili le seguenti possibilità/comandi:
	<ul>
	<li><b>ONOFFCommand</b>: abilitazione/disabilitazione di un set di widget definito a tempo di design</li>
	
	<li><b>VisibilityCommand</b>: rendere visibile/invisibile un set di widget definito a tempo di design</li>
	
	<li><b>JumpCommand</b>: saltare ad una schermata (<b>ContentPanel</b>) differente da quella corrente</li>
	
	<li><b>JumpExtCommand</b>: saltare ad una pagina, tramite link diretto (in genere utilizzato per uscire
	  dal contesto applicativo corrente e puntare, ad esempio, ad una pagina statica o ad un'applicazione esterna</li>
	
	<li><b>ExecCommand</b>: eseguire una logica applicativa java e, a seconda dell'esito (1 o più di uno) eseguire altre 
	  sequenze di comandi</li>
	
	<li><b>SequenceCommand</b>: eseguire una sequenza di comandi</li>
	
	</ul>
	
	La struttura di comandi che devono essere eseguiti a fronte di un evento di U.I su un particolare widget sono modellati
	e sono implementati automaticamente dal codice generato, ad esclusione dell'<b>ExecCommand</b>. In quest'ultimo caso, infatti,
	sebbene il codice generato provveda a richiamare automaticamente un metodo di business fornendogli il contesto applicativo e 
	modificando il contesto applicativo con i risultati dell'esecuzione di tale metodo, il metodo di business deve essere codificato 
	manualmente inel linguaggio target (java). Al momento questo rappresenta l'unico punto di intervento manuale post-generazione sul codice.  
    </p>
   </body>
</html>
